### **LLM智能代理网关：需求规格说明与技术实施方案**

**版本**: 1.0
**日期**: 2025年10月31日

#### **1. 项目概述**

本项目旨在开发一个高性能的HTTP中间代理服务，专门用于代理对大型语言模型（LLM）的API调用。该“智能代理网关”的核心能力是，根据后台动态配置的路由规则，实时地修改请求的目标URL、认证信息（如`Authorization`头）以及其他请求参数，同时必须无损地支持LLM的流式响应特性。

此网关将解决以下核心痛点：
*   **统一访问入口**：为多种不同的LLM服务提供一个统一、稳定的API入口。
*   **密钥集中管理**：将上游服务的API密钥集中在网关层管理，提高安全性，避免密钥在多个客户端中泄露。
*   **灵活动态路由**：无需重启服务，即可通过Web管理后台实时切换、灰度或A/B测试不同的LLM模型或供应商。
*   **请求增强与控制**：在请求转发前，可进行统一的逻辑处理，如添加追踪ID、修改请求体参数等。

---

### **第一部分：需求规格说明 (Requirements Specification)**

#### **2. 功能性需求**

| ID | 需求名称 | 需求描述 | 优先级 |
| :--- | :--- | :--- | :--- |
| **FR-01** | **核心代理能力** | 网关必须能接收客户端的HTTP请求，并将其透明地转发到配置好的上游LLM服务。 | **高** |
| **FR-02** | **流式响应支持** | 必须完美支持基于Chunked Transfer Encoding或Server-Sent Events (SSE)的流式响应，代理过程不能引入缓冲，保证客户端能实时接收到LLM生成的每一个字符。 | **高** |
| **FR-03** | **动态规则引擎** | 网关的行为由一系列路由规则驱动。每条规则包含“匹配条件”和“执行动作”两部分。 | **高** |
| **FR-04** | **灵活的匹配条件** | 规则的匹配条件应至少支持：HTTP请求路径（前缀匹配）、HTTP请求方法（如GET, POST）、HTTP请求头（精确或正则匹配）。 | **高** |
| **FR-05** | **丰富的执行动作** | 规则匹配成功后，应支持执行以下动作：修改目标URL、设置/添加/移除请求头（特别是`Authorization`）、使用正则表达式重写URL路径。 | **高** |
| **FR-06** | **Web管理后台** | 提供一个图形化的Web管理界面，允许管理员对路由规则进行增、删、改、查（CRUD）操作，并能启用/禁用特定规则。 | **高** |
| **FR-07** | **配置实时生效** | 在Web后台对规则的任何修改，都必须立即在所有网关实例上生效，无需重启服务。 | **高** |
| **FR-08** | **规则优先级** | 支持为规则设置优先级，当一个请求同时满足多条规则的匹配条件时，仅执行优先级最高的规则。 | **中** |
| **FR-09** | **(可选)请求体修改** | 支持在执行动作中，修改请求体（Request Body）中的JSON字段。例如，强制将`"model"`字段修改为特定值。 | **中** |
| **FR-10**| **(可选)脚本引擎** | 为应对极端复杂的场景，可为规则提供一个嵌入JavaScript脚本的能力，允许管理员编写自定义代码来处理请求。此功能需有严格的安全沙箱和权限控制。 | **低** |

#### **3. 非功能性需求**

| ID | 需求名称 | 需求描述 |
| :--- | :--- | :--- |
| **NFR-01** | **高性能** | 代理转发过程引入的额外延迟（Overhead）应在毫秒级别，并能支持高并发连接。 |
| **NFR-02** | **高可用性** | 系统应设计为无状态服务，易于水平扩展和部署。配置中心（数据库/Redis）应采用高可用架构。 |
| **NFR-03** | **安全性** | Web管理后台需要有用户认证和授权机制。所有敏感配置（如API密钥）在存储和传输时应加密。 |
| **NFR-04** | **可维护性** | 代码结构清晰，模块解耦。配置和业务逻辑分离，便于未来功能扩展。 |
| **NFR-05** | **可观测性** | 提供详细的日志记录（访问日志、错误日志），并易于接入Prometheus等监控系统，暴露关键性能指标（如请求延迟、QPS、错误率）。 |

---

### **第二部分：技术实施方案 (Technical Implementation Plan)**

#### **4. 系统架构**

本系统采用单一服务（Monolith）架构，该服务同时承载代理核心和Web管理后台两大功能，通过引入PostgreSQL作为配置的持久层，Redis作为配置缓存和实时通知总线，实现高性能和动态性。

**数据流:**
*   **代理请求流 (热路径)**: `客户端 -> Go代理服务 -> Redis (读取规则) -> 上游LLM服务`
*   **配置管理流 (冷路径)**: `管理员 -> Go Web后台 -> PostgreSQL (写入规则) -> Redis (发布更新通知)`

#### **5. 技术选型**

| 组件 | 技术 | 理由 |
| :--- | :--- | :--- |
| **后端语言** | **Go (Golang)** | 原生支持高并发和网络编程，`httputil.ReverseProxy`完美支持流式代理，编译为单一二进制文件，部署简单。 |
| **Web框架** | **Gin** 或 **Echo** | 高性能、API开发效率高，生态成熟。 |
| **数据库 (持久层)** | **PostgreSQL** | 功能强大，稳定可靠，支持JSONB等高级数据类型，作为配置的“事实来源(Source of Truth)”。 |
| **缓存/消息总线** | **Redis** | 极快的内存读写性能，用于缓存路由规则以降低延迟。其Pub/Sub功能是实现配置热加载的关键。 |
| **ORM** | **GORM** | 主流的Go ORM库，简化数据库操作，支持多种数据库方言，便于在开发环境中使用SQLite。 |
| **脚本引擎 (可选)**| **goja** | 成熟的高性能Go语言JavaScript引擎，安全沙箱能力强。 |
| **开发与部署** | **Docker & Docker Compose** | **强烈推荐**。统一开发、测试和生产环境，消除环境不一致带来的风险，简化部署流程。 |

#### **6. 数据模型设计**

规则将以JSON格式存储在PostgreSQL中，并缓存在Redis。对应的Go结构体如下：

```go
// Rule 定义了一条完整的代理规则
type Rule struct {
    ID          string       `json:"id" gorm:"primaryKey"`
    Priority    int          `json:"priority" gorm:"index"` // 优先级
    Matcher     string       `json:"matcher" gorm:"type:jsonb"` // Matcher结构的JSON序列化
    Actions     string       `json:"actions" gorm:"type:jsonb"` // Actions结构的JSON序列化
    Enabled     bool         `json:"enabled" gorm:"default:true"`
}

// Matcher (在代码中定义，存储时序列化为JSON)
type Matcher struct {
    PathPrefix  string            `json:"path_prefix,omitempty"`
    Methods     []string          `json:"methods,omitempty"`
    Headers     map[string]string `json:"headers,omitempty"` // 支持正则
}

// Actions (在代码中定义，存储时序列化为JSON)
type Actions struct {
    SetTargetURL     string                 `json:"set_target_url"`
    SetHeaders       map[string]string      `json:"set_headers,omitempty"`
    AddHeaders       map[string]string      `json:"add_headers,omitempty"`
    RemoveHeaders    []string               `json:"remove_headers,omitempty"`
    RewritePathRegex *struct{ P, R string } `json:"rewrite_path_regex,omitempty"`
    Script           string                 `json:"script,omitempty"` // JS脚本
}
```

#### **7. 开发与部署策略**

1.  **环境统一**: 使用 `docker-compose.yml` 文件定义应用服务、PostgreSQL服务和Redis服务。开发者在本地只需运行 `docker-compose up` 即可启动一个与生产环境完全一致的开发环境。
2.  **测试策略**:
    *   **单元测试**: 针对独立的业务逻辑（如规则匹配算法）编写测试。
    *   **集成测试**: 在CI/CD流水线中，使用Docker Compose启动完整的依赖服务，进行端到端的API测试。
3.  **CI/CD流程**:
    *   代码提交触发CI流水线。
    *   运行静态代码检查、单元测试和集成测试。
    *   测试通过后，构建Go应用的Docker镜像并推送到镜像仓库。
    *   CD流水线将最新的镜像部署到生产环境（如Kubernetes集群）。

#### **8. 实施路线图 (建议)**

**第一阶段：核心功能MVP (预计2周)**
1.  搭建Go项目骨架，集成Gin和GORM。
2.  实现纯声明式（无脚本）的规则引擎核心逻辑。
3.  完成代理核心模块，支持流式响应和基于规则的URL、Header修改。
4.  使用PostgreSQL+Redis存储和缓存规则，并实现Pub/Sub热加载。
5.  开发一个基础的Web后台，完成规则的CRUD功能。
6.  编写`docker-compose.yml`，打通开发和部署流程。

**第二阶段：功能增强与优化 (预计1周)**
1.  完善Web后台的UI/UX，增加规则排序、搜索、一键启用/禁用等功能。
2.  增加更丰富的匹配条件和执行动作（如路径正则重写）。
3.  引入详细的日志和基础的Metrics监控。

**第三阶段：高级功能扩展 (按需)**
1.  如果业务需求明确，调研并集成`goja`脚本引擎，并设计严格的安全沙箱机制。
2.  为Web后台增加基于角色的访问控制（RBAC）。